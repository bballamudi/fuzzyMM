HI <- abs(traj$GPS.Bearing[pt_index] - traj$GPS.Bearing[pt_index - 1])
# Distance from the last fix to the downstream junction (m)
d1 <- spDists(last_fix, cbind(V(roads@g)[name == current_link_end]$lon,
V(roads@g)[name == current_link_end]$lat),
longlat = TRUE) * 1000
# Distance travelled since last position fix
t <- as.double(traj$time[pt_index] - traj$time[pt_index-1])
d2 <- (traj$Speed[pt_index]/3.6) * t
# the difference between the distance from the last matched position to
# the downstream junction and the distance travelled by the vehicle since
# the last position fix
delta_d <- d1 - d2
speed <- traj$GPS.Speed[pt_index] / 3.6
hdop <- traj$GPS.HDOP[pt_index]
newdata <- cbind(speed, hdop, alpha, beta, delta_d, HI, HI)
fis2 <- get("fis2", envir = cacheEnv)
# Sometimes warnings are produced saying the data is out of the specified range,
# but these have no negativ impact on the link identification
pred_val <- predict(fis2, newdata)
# Probability of matching the psotion fix on the current link
pred_val
}
pred_val <- smp1(edit_traj, roads, current_link, pt_index)$predicted.val
pred_val
## Subsequent MapMatching Process (SMP-2) at a junction
smp2 <- function(traj, roads = "DigitalRoadNetwork", current_link,
pt_index = "numeric") {
lon <- traj$coords.x1[pt_index]
lat <- traj$coords.x2[pt_index]
rec <- err_region(lon, lat)
current_pt <- cbind(lon, lat)
last_fix <- cbind(traj$coords.x1[pt_index - 1], traj$coords.x2[pt_index - 1])
edge_id <- current_link$edge_id
# Current selected link becomes the previous link because SMP-2 chooses a new link
prev_link <- current_link
# Check which node of the prev_link is the end node
if (0 <= prev_link$direction && prev_link$direction <= 180) {
prev_link_end <- ifelse(V(roads@g)[name == prev_link$V1]$lon >= V(roads@g)[name == prev_link$V2]$lon
,prev_link$V1, prev_link$V2)
} else {
prev_link_end <- ifelse(V(roads@g)[name == prev_link$V1]$lon < V(roads@g)[name == prev_link$V2]$lon
,prev_link$V1, prev_link$V2)
}
# Get edges inside the error region
candidate_links <- data.frame(edge_id = unique(c(which(gIntersects(rec, roads@sl, byid = TRUE)),
which(gContains(rec, roads@sl, byid = TRUE)))))
# Nodes of the candidate links
candidate_links$V1 <- get.edgelist(roads@g)[candidate_links$edge_id, 1]
candidate_links$V2 <- get.edgelist(roads@g)[candidate_links$edge_id, 2]
candidate_links <- candidate_links[!candidate_links$edge_id == edge_id,]
# Check if the line segments are connected to the prev_link
candidate_links$conn <- sapply(candidate_links[,c("edge_id")],
function(x) {
# edges connected to the previously selected link
conn_edges <- E(roads@g)[from(prev_link_end)]
if (isTRUE(any(as.vector(conn_edges) == x))) 1 else 0
})
# Calculate the perpendicular distance from the current point to all
# segments inside the error region and the closest point on the segments
PD <- sapply(candidate_links[,c("edge_id")],
function(x) dist2Line(current_pt, roads@sl@lines[[x]]@Lines[[1]]@coords))
# Perpendicular distance
candidate_links$PD <- PD[1,]
# Nearest point
candidate_links$NP_x <- PD[2,]
candidate_links$NP_y <- PD[3,]
# Calculate the beraing of the segments
# If a segment is defined by the points a and b, bearing can be:
# bearing(a,b) or bearing(b,a)
# Which one is chosen depends on the differnce between the bearing and the GPS.Bearing
gps_bearing <- traj$GPS.Bearing[pt_index]
candidate_links$direction <- sapply(candidate_links$edge_id,
function(x) {
bearing <- bearing(roads@sl@lines[[x]]@Lines[[1]]@coords[1,],
roads@sl@lines[[x]]@Lines[[1]]@coords[2,])
if (bearing - gps_bearing <= -90) {
bearing <- bearing + 180
if (bearing > 360) bearing <- bearing - 360
bearing
} else if (bearing - gps_bearing > 90) {
bearing <- bearing - 180
if (bearing < 0) bearing <- bearing + 360
bearing
} else bearing
})
# Calculate the heading error
candidate_links$HE <- abs(candidate_links$direction - traj$GPS.Bearing[pt_index])
# Distance (m) from last fix to the end node of the prev_link
end_node <- cbind(V(roads@g)[name == prev_link_end]$lon, V(roads@g)[name == prev_link_end]$lat)
d1 <- spDists(end_node, last_fix, longlat = TRUE) * 1000
# Shortest path from prev_link_end to the segments and closest vertex of the segments
sp <- as.data.frame(do.call(rbind,
lapply(1:nrow(candidate_links),
function(x) {
spV1 <- shortest.paths(roads@g, prev_link_end, candidate_links$V1[x])
spV2 <- shortest.paths(roads@g, prev_link_end, candidate_links$V2[x])
if (spV1 < spV2) {
c(candidate_links$V1[x], spV1)
} else {
c(candidate_links$V2[x], spV2)}})))
candidate_links$cl_vertex <- as.character(as.vector(sp[,1]))
# length of the shortest path (m)
candidate_links$sp <- as.numeric(as.vector(sp[,2]))
candidate_links$sp[is.infinite(candidate_links$sp)] <- 300
# Distance on the candidate links: from the start node of the link to
# the nearest point on the link from the current position fix
candidate_links$d_link <- apply(candidate_links[,c("NP_x", "NP_y", "cl_vertex")], 1,
function(z)
spDists(cbind(V(roads@g)[name == z[3]]$lon,V(roads@g)[name == z[3]]$lat),
cbind(as.numeric(z[1]), as.numeric(z[2])),
longlat = TRUE) * 1000)
# Distance travelled since last position fix
t <- as.double(traj$time[pt_index] - traj$time[pt_index-1])
d <- (traj$Speed[pt_index]/3.6) * t
# Distance error
candidate_links$dist_err <- apply(candidate_links[,c("sp", "d_link")], 1,
function(x) abs(d - (d1 + x[1] + x[2])))
speed <- traj$GPS.Speed[pt_index] / 3.6
hdop <- traj$GPS.HDOP[pt_index]
# Prepare data for FIS3: speed, HE, PD, HDOP, connectivity, dist_err
newdata <- cbind(rep(speed, nrow(candidate_links)),
candidate_links$HE,
candidate_links$PD,
rep(hdop, nrow(candidate_links)),
candidate_links$conn,
candidate_links$dist_err)
fis3 <- get("fis3", envir = cacheEnv)
# Probability of being the correct link
# Sometimes warnings are produced saying the data is out of the specified range,
# but these have no negativ impact on the link identification
candidate_links$pred <- predict(fis3, newdata)$predicted.val
# Current link the vehicle is traveling on
current_link <- candidate_links[candidate_links$pred ==
max(candidate_links$pred),][,c("V1", "V2", "edge_id", "direction", "NP_x", "NP_y")]
current_link
}
current_link <- smp2(edit_traj, roads, current_link, pt_index)
current_link
edit_traj$coords.x1[pt_index] <- current_link$NP_x
edit_traj$coords.x2[pt_index] <- current_link$NP_y
edit_traj$OSM_ID[pt_index] <- E(roads@g)[current_link$edge_id]$name
pt_index <- pt_index + 1
pt_index
View(edit_traj)
pred_val <- smp1(edit_traj, roads, current_link, pt_index)$predicted.val
pred_val
current_link <- smp2(edit_traj, roads, current_link, pt_index)
current_link
edit_traj$coords.x1[pt_index] <- current_link$NP_x
edit_traj$coords.x2[pt_index] <- current_link$NP_y
edit_traj$OSM_ID[pt_index] <- E(roads@g)[current_link$edge_id]$name
pt_index <- pt_index + 1
smp1(edit_traj, roads, current_link, pt_index)$predicted.val
current_link <- smp2(edit_traj, roads, current_link, pt_index)
current_link
edit_traj$coords.x1[pt_index] <- current_link$NP_x
edit_traj$coords.x2[pt_index] <- current_link$NP_y
edit_traj$OSM_ID[pt_index] <- E(roads@g)[current_link$edge_id]$name
pt_index <- pt_index + 1
smp1(edit_traj, roads, current_link, pt_index)$predicted.val
current_link <- smp2(edit_traj, roads, current_link, pt_index)
current_link
edit_traj$coords.x1[pt_index] <- current_link$NP_x
edit_traj$coords.x2[pt_index] <- current_link$NP_y
edit_traj$OSM_ID[pt_index] <- E(roads@g)[current_link$edge_id]$name
pt_index <- pt_index + 1
plot(track$coords.x1[1:12], track$coords.x2[1:12], pch = 16, col="blue")
roads<-create_drn(bbox(track))
lines(roads@sl, col="black")
points(edit_traj$coords.x1, edit_traj$coords.x2,pch=16, col = "red")
smp1(edit_traj, roads, current_link, pt_index)$predicted.val
current_link <- smp2(edit_traj, roads, current_link, pt_index)
current_link
edit_traj$coords.x1[pt_index] <- current_link$NP_x
edit_traj$coords.x2[pt_index] <- current_link$NP_y
edit_traj$OSM_ID[pt_index] <- E(roads@g)[current_link$edge_id]$name
pt_index <- pt_index + 1
plot(track$coords.x1[1:20], track$coords.x2[1:20], pch = 16, col="blue")
lines(roads@sl, col="black")
points(edit_traj$coords.x1, edit_traj$coords.x2,pch=16, col = "red")
smp1(edit_traj, roads, current_link, pt_index)$predicted.val
current_link <- smp2(edit_traj, roads, current_link, pt_index)
edit_traj$coords.x1[pt_index] <- current_link$NP_x
edit_traj$coords.x2[pt_index] <- current_link$NP_y
edit_traj$OSM_ID[pt_index] <- E(roads@g)[current_link$edge_id]$name
pt_index <- pt_index + 1
smp1(edit_traj, roads, current_link, pt_index)$predicted.val
current_link <- smp2(edit_traj, roads, current_link, pt_index)
edit_traj$coords.x1[pt_index] <- current_link$NP_x
edit_traj$coords.x2[pt_index] <- current_link$NP_y
edit_traj$OSM_ID[pt_index] <- E(roads@g)[current_link$edge_id]$name
pt_index <- pt_index + 1
smp1(edit_traj, roads, current_link, pt_index)$predicted.val
current_link <- smp2(edit_traj, roads, current_link, pt_index)
edit_traj$coords.x1[pt_index] <- current_link$NP_x
edit_traj$coords.x2[pt_index] <- current_link$NP_y
edit_traj$OSM_ID[pt_index] <- E(roads@g)[current_link$edge_id]$name
pt_index <- pt_index + 1
smp1(edit_traj, roads, current_link, pt_index)$predicted.val
current_link <- smp2(edit_traj, roads, current_link, pt_index)
edit_traj$coords.x1[pt_index] <- current_link$NP_x
edit_traj$coords.x2[pt_index] <- current_link$NP_y
edit_traj$OSM_ID[pt_index] <- E(roads@g)[current_link$edge_id]$name
pt_index <- pt_index + 1
smp1(edit_traj, roads, current_link, pt_index)$predicted.val
current_link <- smp2(edit_traj, roads, current_link, pt_index)
edit_traj$coords.x1[pt_index] <- current_link$NP_x
edit_traj$coords.x2[pt_index] <- current_link$NP_y
edit_traj$OSM_ID[pt_index] <- E(roads@g)[current_link$edge_id]$name
pt_index <- pt_index + 1
smp1(edit_traj, roads, current_link, pt_index)$predicted.val
current_link <- smp2(edit_traj, roads, current_link, pt_index)
edit_traj$coords.x1[pt_index] <- current_link$NP_x
edit_traj$coords.x2[pt_index] <- current_link$NP_y
edit_traj$OSM_ID[pt_index] <- E(roads@g)[current_link$edge_id]$name
pt_index <- pt_index + 1
smp1(edit_traj, roads, current_link, pt_index)$predicted.val
current_link <- smp2(edit_traj, roads, current_link, pt_index)
edit_traj$coords.x1[pt_index] <- current_link$NP_x
edit_traj$coords.x2[pt_index] <- current_link$NP_y
edit_traj$OSM_ID[pt_index] <- E(roads@g)[current_link$edge_id]$name
pt_index <- pt_index + 1
current_link
plot(track$coords.x1[1:40], track$coords.x2[1:40], pch = 16, col="blue")
lines(roads@sl, col="black")
points(edit_traj$coords.x1, edit_traj$coords.x2,pch=16, col = "red")
smp1(edit_traj, roads, current_link, pt_index)$predicted.val
current_link <- smp2(edit_traj, roads, current_link, pt_index)
edit_traj$coords.x1[pt_index] <- current_link$NP_x
edit_traj$coords.x2[pt_index] <- current_link$NP_y
edit_traj$OSM_ID[pt_index] <- E(roads@g)[current_link$edge_id]$name
pt_index <- pt_index + 1
smp1(edit_traj, roads, current_link, pt_index)$predicted.val
PD <- dist2Line(edit_traj[,c("coords.x1", "coords.x2")][pt_index,],
roads@sl@lines[[current_link$edge_id]]@Lines[[1]]@coords)
edit_traj$coords.x1[pt_index] <- PD[2]
edit_traj$coords.x2[pt_index] <- PD[3]
edit_traj$OSM_ID[pt_index] <- traj$OSM_ID[pt_index - 1]
pt_index <- pt_index + 1
smp1(edit_traj, roads, current_link, pt_index)$predicted.val
current_link <- smp2(edit_traj, roads, current_link, pt_index)
current_link
edit_traj$coords.x1[pt_index] <- current_link$NP_x
edit_traj$coords.x2[pt_index] <- current_link$NP_y
edit_traj$OSM_ID[pt_index] <- E(roads@g)[current_link$edge_id]$name
pt_index <- pt_index + 1
smp1(edit_traj, roads, current_link, pt_index)$predicted.val
current_link <- smp2(edit_traj, roads, current_link, pt_index)
edit_traj$coords.x1[pt_index] <- current_link$NP_x
edit_traj$coords.x2[pt_index] <- current_link$NP_y
edit_traj$OSM_ID[pt_index] <- E(roads@g)[current_link$edge_id]$name
pt_index <- pt_index + 1
smp1(edit_traj, roads, current_link, pt_index)$predicted.val
current_link <- smp2(edit_traj, roads, current_link, pt_index)
edit_traj$coords.x1[pt_index] <- current_link$NP_x
edit_traj$coords.x2[pt_index] <- current_link$NP_y
edit_traj$OSM_ID[pt_index] <- E(roads@g)[current_link$edge_id]$name
pt_index <- pt_index + 1
smp1(edit_traj, roads, current_link, pt_index)$predicted.val
current_link <- smp2(edit_traj, roads, current_link, pt_index)
edit_traj$coords.x1[pt_index] <- current_link$NP_x
edit_traj$coords.x2[pt_index] <- current_link$NP_y
edit_traj$OSM_ID[pt_index] <- E(roads@g)[current_link$edge_id]$name
pt_index <- pt_index + 1
smp1(edit_traj, roads, current_link, pt_index)$predicted.val
PD <- dist2Line(edit_traj[,c("coords.x1", "coords.x2")][pt_index,],
roads@sl@lines[[current_link$edge_id]]@Lines[[1]]@coords)
edit_traj$coords.x1[pt_index] <- PD[2]
edit_traj$coords.x2[pt_index] <- PD[3]
edit_traj$OSM_ID[pt_index] <- traj$OSM_ID[pt_index - 1]
pt_index <- pt_index + 1
smp1(edit_traj, roads, current_link, pt_index)$predicted.val
PD <- dist2Line(edit_traj[,c("coords.x1", "coords.x2")][pt_index,],
roads@sl@lines[[current_link$edge_id]]@Lines[[1]]@coords)
edit_traj$coords.x1[pt_index] <- PD[2]
edit_traj$coords.x2[pt_index] <- PD[3]
edit_traj$OSM_ID[pt_index] <- traj$OSM_ID[pt_index - 1]
pt_index <- pt_index + 1
smp1(edit_traj, roads, current_link, pt_index)$predicted.val
current_link <- smp2(edit_traj, roads, current_link, pt_index)
current_link
lon <- traj$coords.x1[pt_index]
lat <- traj$coords.x2[pt_index]
rec <- err_region(lon, lat)
current_pt <- cbind(lon, lat)
last_fix <- cbind(traj$coords.x1[pt_index - 1], traj$coords.x2[pt_index - 1])
edge_id <- current_link$edge_id
prev_link <- current_link
# Check which node of the prev_link is the end node
if (0 <= prev_link$direction && prev_link$direction <= 180) {
prev_link_end <- ifelse(V(roads@g)[name == prev_link$V1]$lon >= V(roads@g)[name == prev_link$V2]$lon
,prev_link$V1, prev_link$V2)
} else {
prev_link_end <- ifelse(V(roads@g)[name == prev_link$V1]$lon < V(roads@g)[name == prev_link$V2]$lon
,prev_link$V1, prev_link$V2)
}
View(prev_link)
prev_link_end
candidate_links <- data.frame(edge_id = unique(c(which(gIntersects(rec, roads@sl, byid = TRUE)),
which(gContains(rec, roads@sl, byid = TRUE)))))
View(candidate_links)
library(fuzzyMM)
importEnviroCar = function(file) {
require(rjson) # fromJSON
require(maptools) # spCbind
require(rgdal) #readOGR
require(RCurl) #getURL
require(stringr) #str_replace_all
# read data as spatial object:
layer = readOGR(getURL(file,ssl.verifypeer = FALSE), layer = "OGRGeoJSON")
# convert time from text to POSIXct:
layer$time = as.POSIXct(layer$time, format="%Y-%m-%dT%H:%M:%SZ")
# the third column is JSON, we want it in a table (data.frame) form:
# 1. form a list of lists
l1 = lapply(as.character(layer[[3]]), fromJSON)
# 2. parse the $value elements in the sublist:
l2 = lapply(l1,function(x) as.data.frame(lapply(x, function(X) X$value)))
# create a matrix with all columns and then convert it to a data frame
# thanks to Kristina Helle!
# dynamic parsing of phenomenon names and units
phenomenonsUrl = "https://www.envirocar.org/api/stable/phenomenons"
phenomenons = fromJSON(getURL(phenomenonsUrl,ssl.verifypeer = FALSE))
colNames <- c("GPS.Bearing", "GPS.HDOP", "GPS.Speed")
if (!all(colNames %in% names(l2[[1]])))
stop("Track does not contain all the necessary data (GPS.Bearing, GPS.HDOP, GPS.Speed)")
else
colNames <- names(l2[[1]])
resultMatrix = matrix(nrow = length(l2),ncol = length(colNames))
dimnames(resultMatrix)[[2]] = colNames
for (i in seq(along = l2))
resultMatrix[i,colNames] = as.numeric(l2[[i]])[match(colNames, names(l2[[i]]))]
result = as.data.frame(resultMatrix)
# set the units:
units <- sapply(phenomenons[[1]], "[[", "unit")
names(units)=colNames
# add a units attribute to layer
layer[[3]] = NULL
# add the table as attributes to the spatial object
if (length(layer) == nrow(result)) {
layer = spCbind(layer, result)
attr(layer, "units") = units
layer
} else
NULL
}
url = "https://envirocar.org/api/stable/tracks/52cbb887e4b0f9afbd8eafc2"
track = importEnviroCar(url)
test<-mm(track, T)
url = "https://envirocar.org/api/stable/tracks/52e39b02e4b0d8e8c22665c3"
track = importEnviroCar(url)
test<-mm(track, T)
url = "https://envirocar.org/api/stable/tracks/52b45583e4b0f9afbd29bb6b"  #200
track = importEnviroCar(url)
test<-mm(track, T)
plot(track$coords.x1[1:40], track$coords.x2[1:40], pch = 16, col="blue")
track1<-test
points(track1$coords.x1, track1$coords.x2,pch=16, col = "red")
roads<-create_drn(bbox(track))
lines(roads@sl, col="black")
plot(track$coords.x1[1:6], track$coords.x2[1:6], pch = 16, col="blue")
points(track1$coords.x1, track1$coords.x2,pch=16, col = "red")
lines(roads@sl, col="black")
url = "https://envirocar.org/api/stable/tracks/52cf2af0e4b0f9afbde8149c"  #20
track = importEnviroCar(url)
test<-mm(track, T)
url = "https://envirocar.org/api/stable/tracks/528cf18ee4b0a727145ddece"  #motorway
track = importEnviroCar(url)
test<-mm(track, T)
plot(track$coords.x1[200:300], track$coords.x2[200:300], pch = 16, col="blue")
plot(track$coords.x1[300:400], track$coords.x2[300:400], pch = 16, col="blue")
plot(track$coords.x1[320:350], track$coords.x2[320:350], pch = 16, col="blue")
plot(track$coords.x1[320:370], track$coords.x2[320:370], pch = 16, col="blue")
plot(track$coords.x1[320:360], track$coords.x2[320:360], pch = 16, col="blue")
roads<-create_drn(bbox(track))
lines(roads@sl, col="black")
points(track1$coords.x1, track1$coords.x2,pch=16, col = "red")
track1<-test
points(track1$coords.x1, track1$coords.x2,pch=16, col = "red")
library(fuzzyMM)
test<-mm(track, T)
plot(track$coords.x1[320:360], track$coords.x2[320:360], pch = 16, col="blue")
lines(roads@sl, col="black")
points(track1$coords.x1, track1$coords.x2,pch=16, col = "red")
track1<-test
points(track1$coords.x1, track1$coords.x2,pch=16, col = "red")
plot(track$coords.x1[320:360], track$coords.x2[320:360], pch = 16, col="blue")
points(track1$coords.x1, track1$coords.x2,pch=16, col = "red")
?plot
?par
rr <- rnorm(5)
plot(rr, 1:5,  frame.plot = TRUE)
plot(rr, 1:5, axes = FALSE, frame.plot = TRUE)
rr <- rnorm(5)
plot(rr, 1:5, axes = FALSE, frame.plot = TRUE)
my.at <- round(rr,4)
axis(1, at = my.at, labels = my.at)
rr <- rnorm(5)
plot(1:5,rr, axes = FALSE, frame.plot = TRUE)
my.at <- round(rr,4)
axis(2, at = my.at, labels = my.at)
importEnviroCar = function(file) {
require(rjson) # fromJSON
require(maptools) # spCbind
require(rgdal) #readOGR
require(RCurl) #getURL
require(stringr) #str_replace_all
# read data as spatial object:
layer = readOGR(getURL(file,ssl.verifypeer = FALSE), layer = "OGRGeoJSON")
# convert time from text to POSIXct:
layer$time = as.POSIXct(layer$time, format="%Y-%m-%dT%H:%M:%SZ")
# the third column is JSON, we want it in a table (data.frame) form:
# 1. form a list of lists
l1 = lapply(as.character(layer[[3]]), fromJSON)
# 2. parse the $value elements in the sublist:
l2 = lapply(l1,function(x) as.data.frame(lapply(x, function(X) X$value)))
# create a matrix with all columns and then convert it to a data frame
# thanks to Kristina Helle!
# dynamic parsing of phenomenon names and units
phenomenonsUrl = "https://www.envirocar.org/api/stable/phenomenons"
phenomenons = fromJSON(getURL(phenomenonsUrl,ssl.verifypeer = FALSE))
colNames <- c("GPS.Bearing", "GPS.HDOP", "GPS.Speed")
if (!all(colNames %in% names(l2[[1]])))
stop("Track does not contain all the necessary data (GPS.Bearing, GPS.HDOP, GPS.Speed)")
else
colNames <- names(l2[[1]])
resultMatrix = matrix(nrow = length(l2),ncol = length(colNames))
dimnames(resultMatrix)[[2]] = colNames
for (i in seq(along = l2))
resultMatrix[i,colNames] = as.numeric(l2[[i]])[match(colNames, names(l2[[i]]))]
result = as.data.frame(resultMatrix)
# set the units:
units <- sapply(phenomenons[[1]], "[[", "unit")
names(units)=colNames
# add a units attribute to layer
layer[[3]] = NULL
# add the table as attributes to the spatial object
if (length(layer) == nrow(result)) {
layer = spCbind(layer, result)
attr(layer, "units") = units
layer
} else
NULL
}
url = "https://envirocar.org/api/stable/tracks/528cf18ee4b0a727145ddece"  #motorway
library(fuzzyMM)
library(fuzzyMM)
track1<-mm(track, T)
traj<-track
track = importEnviroCar(url)
track1<-mm(track, T)
plot(track$coords.x1[320:360], track$coords.x2[320:360], pch = 16, col="blue")
points(track1$coords.x1, track1$coords.x2,pch=16, col = "red")
library(fuzzyMM)
track1<-mm(track, T)
plot(track$coords.x1[320:360], track$coords.x2[320:360], pch = 16, col="blue")
points(track1$coords.x1, track1$coords.x2,pch=16, col = "red")
importEnviroCar = function(file) {
require(rjson) # fromJSON
require(maptools) # spCbind
require(rgdal) #readOGR
require(RCurl) #getURL
require(stringr) #str_replace_all
# read data as spatial object:
layer = readOGR(getURL(file,ssl.verifypeer = FALSE), layer = "OGRGeoJSON")
# convert time from text to POSIXct:
layer$time = as.POSIXct(layer$time, format="%Y-%m-%dT%H:%M:%SZ")
# the third column is JSON, we want it in a table (data.frame) form:
# 1. form a list of lists
l1 = lapply(as.character(layer[[3]]), fromJSON)
# 2. parse the $value elements in the sublist:
l2 = lapply(l1,function(x) as.data.frame(lapply(x, function(X) X$value)))
# create a matrix with all columns and then convert it to a data frame
# thanks to Kristina Helle!
# dynamic parsing of phenomenon names and units
phenomenonsUrl = "https://www.envirocar.org/api/stable/phenomenons"
phenomenons = fromJSON(getURL(phenomenonsUrl,ssl.verifypeer = FALSE))
colNames <- c("GPS.Bearing", "GPS.HDOP", "GPS.Speed")
if (!all(colNames %in% names(l2[[1]])))
stop("Track does not contain all the necessary data (GPS.Bearing, GPS.HDOP, GPS.Speed)")
else
colNames <- names(l2[[1]])
resultMatrix = matrix(nrow = length(l2),ncol = length(colNames))
dimnames(resultMatrix)[[2]] = colNames
for (i in seq(along = l2))
resultMatrix[i,colNames] = as.numeric(l2[[i]])[match(colNames, names(l2[[i]]))]
result = as.data.frame(resultMatrix)
# set the units:
units <- sapply(phenomenons[[1]], "[[", "unit")
names(units)=colNames
# add a units attribute to layer
layer[[3]] = NULL
# add the table as attributes to the spatial object
if (length(layer) == nrow(result)) {
layer = spCbind(layer, result)
attr(layer, "units") = units
layer
} else
NULL
}
url = "https://envirocar.org/api/stable/tracks/528cf18ee4b0a727145ddece"  #motorway
track = importEnviroCar(url)
remove.packages("fuzzyMM")
library(fuzzyMM)
track1<-m(track)
track1<-mm(track)
plot(track$coords.x1[320:360], track$coords.x2[320:360], pch = 16, col="blue")
points(track1$coords.x1, track1$coords.x2,pch=16, col = "red")
install.packages(c("colorspace", "digest", "frbs", "geosphere", "igraph", "labeling", "mapproj", "maps", "maptools", "munsell", "plyr", "png", "raster", "rgdal", "rgl", "RgoogleMaps", "rJava", "sp", "spacetime", "xts", "zoo"))
install.packages("roxygen2")
install.packages("rgeos")
install.packages("knitr")
library("knitr")
