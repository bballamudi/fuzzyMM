{
    "contents" : "## Subsequent MapMatching Process (SMP-2) at a junction \nsmp2 <- function(traj, roads = \"DigitalRoadNetwork\", current_link, \n                 pt_index = \"numeric\") {\n    \n  lon <- traj$coords.x1[pt_index] \n  lat <- traj$coords.x2[pt_index] \n  rec <- err_region(lon, lat)\n\n  current_pt <- cbind(lon, lat)\n  last_fix <- cbind(traj$coords.x1[pt_index - 1], traj$coords.x2[pt_index - 1])\n  edge_id <- current_link$edge_id\n  \n  # Current selected link becomes the previous link because SMP-2 chooses a new link\n  prev_link <- current_link\n  \n  # Check which node of the prev_link is the end node\n  if (0 <= prev_link$direction && prev_link$direction <= 180) {\n    prev_link_end <- ifelse(V(roads@g)[name == prev_link$V1]$lon >= V(roads@g)[name == prev_link$V2]$lon\n                                ,prev_link$V1, prev_link$V2)\n  } else {\n    prev_link_end <- ifelse(V(roads@g)[name == prev_link$V1]$lon < V(roads@g)[name == prev_link$V2]$lon\n                               ,prev_link$V1, prev_link$V2)\n  }\n    \n  # Get edges inside the error region \n  candidate_links <- data.frame(edge_id = unique(c(which(gIntersects(rec, roads@sl, byid = TRUE)), \n                                                   which(gContains(rec, roads@sl, byid = TRUE)))))\n  # Nodes of the candidate links\n  candidate_links$V1 <- get.edgelist(roads@g)[candidate_links$edge_id, 1]\n  candidate_links$V2 <- get.edgelist(roads@g)[candidate_links$edge_id, 2]\n  candidate_links <- candidate_links[!candidate_links$edge_id == edge_id,]\n \n  # Check if the line segments are connected to the prev_link\n  candidate_links$conn <- sapply(candidate_links[,c(\"edge_id\")],                         \n                                 function(x) {\n                                   # edges connected to the previously selected link\n                                   conn_edges <- E(roads@g)[from(prev_link_end)] \n                                   if (isTRUE(any(as.vector(conn_edges) == x))) 1 else 0\n                                   })\n  \n  # Calculate the perpendicular distance from the current point to all \n  # segments inside the error region and the closest point on the segments\n  PD <- sapply(candidate_links[,c(\"edge_id\")], \n               function(x) dist2Line(current_pt, roads@sl@lines[[x]]@Lines[[1]]@coords))\n  \n  # Perpendicular distance\n  candidate_links$PD <- PD[1,]\n  # Nearest point\n  candidate_links$NP_x <- PD[2,]\n  candidate_links$NP_y <- PD[3,]\n    \n  \n  # Calculate the beraing of the segments\n  # If a segment is defined by the points a and b, bearing can be:\n  # bearing(a,b) or bearing(b,a)\n  # Which one is chosen depends on the differnce between the bearing and the GPS.Bearing\n  gps_bearing <- traj$GPS.Bearing[pt_index]\n  candidate_links$direction <- sapply(candidate_links$edge_id, \n                                      function(x) {\n                                        bearing <- bearing(roads@sl@lines[[x]]@Lines[[1]]@coords[1,],\n                                                           roads@sl@lines[[x]]@Lines[[1]]@coords[2,])\n                                        if (bearing - gps_bearing <= -90) {\n                                          bearing <- bearing + 180\n                                          if (bearing > 360) bearing <- bearing - 360\n                                          bearing\n                                        } else if (bearing - gps_bearing > 90) {\n                                          bearing <- bearing - 180\n                                          if (bearing < 0) bearing <- bearing + 360\n                                          bearing\n                                        } else bearing\n                                      }) \n  \n  # Calculate the heading error\n  candidate_links$HE <- abs(candidate_links$direction - traj$GPS.Bearing[pt_index])\n  \n  # Distance (m) from last fix to the end node of the prev_link\n  end_node <- cbind(V(roads@g)[name == prev_link_end]$lon, V(roads@g)[name == prev_link_end]$lat)\n  d1 <- spDists(end_node, last_fix, longlat = TRUE) * 1000\n  \n  \n  # Shortest path from prev_link_end to the segments and closest vertex of the segments\n  sp <- as.data.frame(do.call(rbind, \n                              lapply(1:nrow(candidate_links), \n                                     function(x) {\n                                       spV1 <- shortest.paths(roads@g, prev_link_end, candidate_links$V1[x])\n                                       spV2 <- shortest.paths(roads@g, prev_link_end, candidate_links$V2[x])\n                                       if (spV1 < spV2) {\n                                         c(candidate_links$V1[x], spV1)\n                                       } else {\n                                         c(candidate_links$V2[x], spV2)}})))\n  \n  candidate_links$cl_vertex <- as.character(as.vector(sp[,1]))\n  # length of the shortest path (m)\n  candidate_links$sp <- as.numeric(as.vector(sp[,2]))\n  candidate_links$sp[is.infinite(candidate_links$sp)] <- 300\n  \n  # Distance on the candidate links: from the start node of the link to\n  # the nearest point on the link from the current position fix\n  candidate_links$d_link <- apply(candidate_links[,c(\"NP_x\", \"NP_y\", \"cl_vertex\")], 1,\n                            function(z) \n                              spDists(cbind(V(roads@g)[name == z[3]]$lon,V(roads@g)[name == z[3]]$lat),\n                                                cbind(as.numeric(z[1]), as.numeric(z[2])), \n                                                longlat = TRUE) * 1000)\n  \n  # Distance travelled since last position fix\n  t <- as.double(traj$time[pt_index] - traj$time[pt_index-1])\n  d <- (traj$Speed[pt_index]/3.6) * t\n  \n  # Distance error\n  candidate_links$dist_err <- apply(candidate_links[,c(\"sp\", \"d_link\")], 1,\n                              function(x) abs(d - (d1 + x[1] + x[2]))) \n\n  \n  speed <- traj$GPS.Speed[pt_index] / 3.6\n  hdop <- traj$GPS.HDOP[pt_index]\n  \n  # Prepare data for FIS3: speed, HE, PD, HDOP, connectivity, dist_err\n  newdata <- cbind(rep(speed, nrow(candidate_links)), \n                   candidate_links$HE,\n                   candidate_links$PD, \n                   rep(hdop, nrow(candidate_links)), \n                   candidate_links$conn, \n                   candidate_links$dist_err)\n  \n  fis3 <- get(\"fis3\", envir = cacheEnv)\n  # Probability of being the correct link\n  # Sometimes warnings are produced saying the data is out of the specified range,\n  # but these have no negativ impact on the link identification\n  candidate_links$pred <- predict(fis3, newdata)$predicted.val\n  \n  # Current link the vehicle is traveling on\n  current_link <- candidate_links[candidate_links$pred ==\n                              max(candidate_links$pred),][,c(\"V1\", \"V2\", \"edge_id\", \"direction\", \"NP_x\", \"NP_y\")] \n  \n  current_link \n}\n\n\n\n\n\n\n\n",
    "created" : 1390761451492.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1354674106",
    "id" : "98A3DFB1",
    "lastKnownWriteTime" : 1394106057,
    "path" : "D:/Dropbox/Bachelorarbeit/package/fuzzyMM/R/SMP2.R",
    "project_path" : "R/SMP2.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}