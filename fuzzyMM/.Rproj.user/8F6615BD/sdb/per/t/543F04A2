{
    "contents" : "## Initial MapMatching Process: identifies the intial road link \nimp <- function (traj, roads = \"DigitalRoadNetwork\") { \n  i <- 1\n  count <- 0\n  found <- FALSE\n  initial_links <- data.frame(V1 = numeric(0), V2 = numeric(0), edge_id = numeric(0), \n                                direction = numeric(0), NP_x = numeric(0), NP_y = numeric(0))\n  while (!found){\n    # Get coordinates of the current position and create SpatialPoints\n    lon <- traj$coords.x1[i] #lon\n    lat <- traj$coords.x2[i] #lat\n    current_pt <- cbind(lon, lat)\n    rec <- err_region(lon, lat)\n    \n    # Get edges inside the error region \n    candidate_links <- data.frame(edge_id = unique(c(which(gIntersects(rec, roads@sl, byid = TRUE)), \n                                                     which(gContains(rec, roads@sl, byid = TRUE)))))\n    \n    # Nodes of the candidate links\n    candidate_links$V1 <- get.edgelist(roads@g)[candidate_links$edge_id, 1]\n    candidate_links$V2 <- get.edgelist(roads@g)[candidate_links$edge_id, 2]\n    \n    \n    # Calculate the perpendicular distance from the current point to all \n    # segments inside the error region and the closest point on the segments\n    PD <- sapply(candidate_links[,c(\"edge_id\")], \n                 function(x) dist2Line(current_pt, roads@sl@lines[[x]]@Lines[[1]]@coords))\n    \n    # Perpendicular distance\n    candidate_links$PD <- PD[1,]\n    # Nearest point\n    candidate_links$NP_x <- PD[2,]\n    candidate_links$NP_y <- PD[3,]\n    \n    # Calculate the beraing of the segments\n    # If a segment is defined by the points a and b, bearing can be:\n    # bearing(a,b) or bearing(b,a)\n    # Which one is chosen depends on the differnce between the bearing and the GPS.Bearing\n    gps_bearing <- traj$GPS.Bearing[i]\n    candidate_links$direction <- sapply(candidate_links$edge_id, \n                                  function(x) {\n                                    bearing <- bearing(roads@sl@lines[[x]]@Lines[[1]]@coords[1,],\n                                                       roads@sl@lines[[x]]@Lines[[1]]@coords[2,])\n                                    if (bearing - gps_bearing <= -90) {\n                                      bearing <- bearing + 180\n                                      if (bearing > 360) bearing <- bearing - 360\n                                      bearing\n                                    } else if (bearing - gps_bearing > 90) {\n                                      bearing <- bearing - 180\n                                      if (bearing < 0) bearing <- bearing + 360\n                                      bearing\n                                    } else bearing\n                                  }) \n    \n    # Calculate the heading error\n    candidate_links$HE <- abs(candidate_links$direction - traj$GPS.Bearing[i])\n    \n    speed <- traj$GPS.Speed[i]/3.6\n    hdop <- traj$GPS.HDOP[i]\n    \n    # Prepare data for FIS1: speed, HE, PD, HDOP\n    newdata <- cbind(rep(speed, nrow(candidate_links)), \n                     candidate_links$HE,\n                     candidate_links$PD, \n                     rep(hdop, nrow(candidate_links)))\n    \n    # Get FIS1 from the cache environment\n    fis1 <- get(\"fis1\", envir = cacheEnv)\n    \n    # Probability of being the correct link\n    # Sometimes warnings are produced saying the data is out of the specified range,\n    # but these have no negativ impact on the link identification\n    candidate_links$pred <- predict(fis1, newdata)$predicted.val\n    initial_links[i,] <- candidate_links[candidate_links$pred == \n                                       max(candidate_links$pred),][,c(\"V1\", \"V2\", \"edge_id\", \"direction\", \"NP_x\", \"NP_y\")]\n    \n    # Decide if  a link is the initial link depending on the number\n    # of points matched to the link\n    if (i > 1) {\n      if (identical(E(roads@g)[initial_links$edge_id[i]]$name, \n                    E(roads@g)[initial_links$edge_id[i - 1]]$name)) {\n        count <- count +1\n      } else {\n        count <- 0\n      } \n      if (count == 2) {\n        initial_links <- initial_links[(i - 2):i,]\n        found <- TRUE\n      }\n    }\n    i <- i + 1\n  }\n  \n  # Matched coordinates \n  traj$coords.x1[(i - 3):(i - 1)] <- initial_links$NP_x\n  traj$coords.x2[(i - 3):(i - 1)] <- initial_links$NP_y\n  #OSM ID of the roads \n  traj$OSM_ID[(i - 3):(i - 1)] <- E(roads@g)[initial_links$edge_id]$name\n  \n  list(traj = traj, index = i, current_link = initial_links[nrow(initial_links),])\n}\n\n\n\n## Create the error region with fixed size using UTM coordinates\n## \n## Args:\n##  x: lon\n##  y: lat\n##\n## Returns:\n##  Error region as SpatialPolygon\nerr_region <- function(x, y) {  \n  current_pt <- data.frame(x, y)\n  coordinates(current_pt) <- ~x + y \n  proj4string(current_pt) <- osm_crs()\n  \n  # Transform to UTM\n  UTMzone <- trunc((180 + 5) / 6) + 1\n  UTM <- CRS(paste0(\"+proj=utm +zone=\",UTMzone,\" +ellps=WGS84 +datum=WGS84\"))\n  current_pt <- spTransform(current_pt, UTM)\n  x <- coordinates(current_pt )[1]\n  y <- coordinates(current_pt )[2]\n  \n  # Create the error region with fixed size and transform back to osm_crs()\n  x_rec <- c(x - 38, x + 38, x + 38, x - 38, x - 38)\n  y_rec <- c(y - 38, y - 38, y + 38, y + 38, y - 38)\n  rec <- cbind(x_rec, y_rec)\n  rec <- Polygons(list(Polygon(rec, hole = FALSE)), 1)\n  rec <- SpatialPolygons(list(rec), proj4string = UTM)\n  rec <- spTransform(rec, osm_crs())\n}\n\n              \n\n\n\n\n\n",
    "created" : 1386162691778.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "923980997",
    "id" : "543F04A2",
    "lastKnownWriteTime" : 1394101434,
    "path" : "D:/Dropbox/Bachelorarbeit/package/fuzzyMM/R/IMP.R",
    "project_path" : "R/IMP.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}